{"ast":null,"code":"function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/* eslint-disable react/no-find-dom-node */\n\n\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // the last page we have items for\n\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect();\n      var nextPageHeight = endRect.top + endRect.height - beginRect.top; // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4;\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0;\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index; // We only need page refs if we don't know the pageHeight\n    // The new way, we pass the ref we want to the children render function.\n\n    var ref;\n    if (!pageHeight && itemsIndex === 0) ref = firstPageItemRef;else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) ref = lastPageItemRef;else if (show && show === itemsIndex) ref = showRef;\n    var child = children(item, itemsIndex, ref); // The old way, if we don't see that our ref was set, wrap it\n\n    if (!pageHeight && itemsIndex === 0 && child.ref !== firstPageItemRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"first\",\n        ref: firstPageItemRef\n      }, child);\n    } else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex) && child.ref !== lastPageItemRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"last\",\n        ref: lastPageItemRef\n      }, child);\n    }\n\n    if (show && show === itemsIndex && child.ref !== showRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"show\",\n        ref: showRef\n      }, child);\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };","map":{"version":3,"sources":["/Users/tessie/Documents/mediary-graphql/client/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","React","Component","useEffect","useMemo","useRef","useState","findDOMNode","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","Ref","_Component","apply","arguments","_proto","render","children","props","InfiniteScroll","_ref","_ref$items","items","onMore","renderMarker","replace","show","_ref$step","step","lastPage","Math","floor","length","_useState","beginPage","setBeginPage","_useState2","endPage","setEndPage","_useState3","pageHeight","setPageHeight","_useState4","pageArea","setPageArea","_useState5","multiColumn","setMultiColumn","_useState6","pendingLength","setPendingLength","belowMarkerRef","firstPageItemRef","lastPageItemRef","showRef","current","beginRect","getBoundingClientRect","endRect","nextPageHeight","top","height","nextMultiColumn","nextPageArea","width","scrollParents","onScroll","scrollParent","document","documentElement","scrollTop","body","window","innerHeight","innerWidth","rect","offset","nextBeginPage","min","max","nextEndPage","ceil","forEach","addEventListener","removeEventListener","timer","setTimeout","showNode","scrollIntoView","clearTimeout","firstIndex","lastIndex","result","marker","createElement","key","flex","cloneElement","push","slice","item","index","itemsIndex","ref","child","_marker","InfiniteScrollDoc","process","env","NODE_ENV","require","doc","InfiniteScrollWrapper"],"mappings":"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","sourcesContent":["function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint-disable react/no-find-dom-node */\nimport React, { Component, useEffect, useMemo, useRef, useState } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\n\nvar Ref = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Ref, _Component);\n\n  function Ref() {\n    return _Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Ref.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Ref;\n}(Component);\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n  // the last page we have items for\n  var lastPage = useMemo(function () {\n    return Math.floor(items.length / step);\n  }, [items.length, step]); // the first page we are displaying\n\n  var _useState = useState(0),\n      beginPage = _useState[0],\n      setBeginPage = _useState[1]; // the last page we are displaying\n\n\n  var _useState2 = useState(show ? Math.floor((show + step) / step) - 1 : 0),\n      endPage = _useState2[0],\n      setEndPage = _useState2[1]; // how tall we've measured a page to be\n\n\n  var _useState3 = useState(),\n      pageHeight = _useState3[0],\n      setPageHeight = _useState3[1]; // how much area a page requires\n\n\n  var _useState4 = useState(),\n      pageArea = _useState4[0],\n      setPageArea = _useState4[1]; // whether the items are laid out in a grid instead of linearly\n\n\n  var _useState5 = useState(),\n      multiColumn = _useState5[0],\n      setMultiColumn = _useState5[1]; // what we're waiting for onMore to give us\n\n\n  var _useState6 = useState(0),\n      pendingLength = _useState6[0],\n      setPendingLength = _useState6[1];\n\n  var belowMarkerRef = useRef();\n  var firstPageItemRef = useRef();\n  var lastPageItemRef = useRef();\n  var showRef = useRef(); // calculating space based on where the first and last items being displayed\n  // are located\n\n  useEffect(function () {\n    if (firstPageItemRef.current && lastPageItemRef.current && !pageHeight) {\n      /* eslint-disable react/no-find-dom-node */\n      var beginRect = firstPageItemRef.current.getBoundingClientRect ? firstPageItemRef.current.getBoundingClientRect() : findDOMNode(firstPageItemRef.current).getBoundingClientRect();\n      var endRect = lastPageItemRef.current.getBoundingClientRect ? lastPageItemRef.current.getBoundingClientRect() : findDOMNode(lastPageItemRef.current).getBoundingClientRect();\n      var nextPageHeight = endRect.top + endRect.height - beginRect.top; // Check if the items are arranged in a single column or not.\n\n      var nextMultiColumn = nextPageHeight / step < endRect.height;\n      var nextPageArea = endRect.height * endRect.width * step;\n      setPageHeight(nextPageHeight);\n      setPageArea(nextPageArea);\n      setMultiColumn(nextMultiColumn);\n    }\n  }, [pageHeight, step]); // scroll handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var onScroll = function onScroll() {\n      var scrollParent = scrollParents[0]; // Determine the window into the first scroll parent\n\n      var top;\n      var height;\n      var width;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n        width = window.innerWidth;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n        width = rect.width;\n      } // Figure out which pages we should make visible based on the scroll\n      // window.\n\n\n      var offset = height / 4;\n      var nextBeginPage = replace ? Math.min(lastPage, Math.max(0, multiColumn ? Math.floor(Math.max(0, top - offset) * width / pageArea) : Math.floor(Math.max(0, top - offset) / pageHeight))) : 0;\n      var nextEndPage = Math.min(lastPage, Math.max(!replace && endPage || 0, multiColumn ? Math.ceil((top + height + offset) * width / pageArea) : Math.floor((top + height + offset) / pageHeight)));\n      if (nextBeginPage !== beginPage) setBeginPage(nextBeginPage);\n      if (nextEndPage !== endPage) setEndPage(nextEndPage);\n    };\n\n    if (pageHeight && belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (scrollParent) {\n        return scrollParent.addEventListener('scroll', onScroll);\n      });\n      onScroll();\n    }\n\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (scrollParent) {\n          return scrollParent.removeEventListener('scroll', onScroll);\n        });\n      }\n    };\n  }, [beginPage, endPage, lastPage, multiColumn, pageArea, pageHeight, replace]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && endPage === lastPage && items.length >= pendingLength) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [endPage, items.length, lastPage, onMore, pendingLength, step]); // scroll to any 'show'\n\n  useEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && showRef.current) {\n        var showNode = showRef.current.scrollIntoView ? showRef.current : findDOMNode(showRef.current);\n        var scrollParent = findScrollParent(showNode);\n\n        if (isNodeBeforeScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(true);\n        } else if (isNodeAfterScroll(showNode, scrollParent)) {\n          showNode.scrollIntoView(false);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [show]);\n  var firstIndex = beginPage * step;\n  var lastIndex = Math.min((endPage + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (replace && pageHeight && firstIndex) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      flex: false,\n      height: beginPage * pageHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index; // We only need page refs if we don't know the pageHeight\n    // The new way, we pass the ref we want to the children render function.\n\n    var ref;\n    if (!pageHeight && itemsIndex === 0) ref = firstPageItemRef;else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex)) ref = lastPageItemRef;else if (show && show === itemsIndex) ref = showRef;\n    var child = children(item, itemsIndex, ref); // The old way, if we don't see that our ref was set, wrap it\n\n    if (!pageHeight && itemsIndex === 0 && child.ref !== firstPageItemRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"first\",\n        ref: firstPageItemRef\n      }, child);\n    } else if (!pageHeight && (itemsIndex === step - 1 || itemsIndex === lastIndex) && child.ref !== lastPageItemRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"last\",\n        ref: lastPageItemRef\n      }, child);\n    }\n\n    if (show && show === itemsIndex && child.ref !== showRef) {\n      child = /*#__PURE__*/React.createElement(Ref, {\n        key: \"show\",\n        ref: showRef\n      }, child);\n    }\n\n    result.push(child);\n  });\n\n  if (endPage < lastPage || replace || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: belowMarkerRef,\n      flex: false,\n      height: (replace ? (lastPage - endPage) * pageHeight : 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      _marker = /*#__PURE__*/React.cloneElement(renderMarker(_marker), {\n        key: 'below'\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nvar InfiniteScrollDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  InfiniteScrollDoc = require('./doc').doc(InfiniteScroll);\n}\n\nvar InfiniteScrollWrapper = InfiniteScrollDoc || InfiniteScroll;\nexport { InfiniteScrollWrapper as InfiniteScroll };"]},"metadata":{},"sourceType":"module"}