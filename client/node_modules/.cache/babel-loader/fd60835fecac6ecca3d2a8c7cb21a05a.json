{"ast":null,"code":"import { normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\nexport var calcs = function calcs(values, options) {\n  if (options === void 0) {\n    options = {};\n  } // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100\n\n\n  var coarseness = options.coarseness || 5; // the number of steps is one less than the number of labels\n\n  var steps = options.steps || [1, 1];\n  var calcValues = normalizeValues(values || []); // min and max y values\n\n  var min;\n  var max;\n\n  if (calcValues.length) {\n    // Calculate the max and min y values.\n    calcValues.filter(function (value) {\n      return value !== undefined;\n    }).forEach(function (value) {\n      var y = value.value[1];\n\n      if (y !== undefined) {\n        min = min === undefined ? y : Math.min(min, y);\n        max = max === undefined ? y : Math.max(max, y);\n      } // handle ranges of values\n\n\n      var y2 = value.value[2];\n\n      if (y2 !== undefined) {\n        min = Math.min(min, y2);\n        max = Math.max(max, y2);\n      }\n    }); // when max === min, offset them so we can show something\n\n    if (max === min) {\n      if (max > 0) min = max - 1;else max = min + 1;\n    } // Calculate some reasonable y bounds based on the max and min y values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis edge label.\n\n\n    var delta = max - min;\n    var interval = Number.parseFloat((delta / coarseness).toPrecision(1));\n    max = max - max % interval + interval;\n    min -= min % interval;\n\n    if (min < 0 && max > 0 && Math.abs(min) !== Math.abs(max)) {\n      // Adjust min and max when crossing 0 to ensure 0 will be shown on\n      // the Y axis based on the number of steps.\n      // const ratio = Math.abs(max) / Math.abs(min);\n      var stepInterval = (max - min) / steps[1];\n      var minSteps = min / stepInterval;\n      var maxSteps = max / stepInterval;\n\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        stepInterval = max / Math.floor(maxSteps);\n        max = stepInterval * Math.floor(maxSteps);\n        min = stepInterval * Math.floor(minSteps);\n      } else {\n        stepInterval = Math.abs(min / Math.ceil(minSteps));\n        min = stepInterval * Math.ceil(minSteps);\n        max = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n\n  if (options.min !== undefined) {\n    var _options = options;\n    min = _options.min;\n  }\n\n  if (options.max !== undefined) {\n    var _options2 = options;\n    max = _options2.max;\n  }\n\n  var bounds;\n  if (calcValues.length > 1) bounds = [[calcValues[0].value[0], calcValues[calcValues.length - 1].value[0]], [min, max]];else if (calcValues.length === 1) // when we only have one value, at least git some x bounds\n    bounds = [[calcValues[0].value[0], calcValues[0].value[0] + 1], [min, max]];else bounds = [[], []];\n  var dimensions = [round(bounds[0][1] - bounds[0][0], 2), round(bounds[1][1] - bounds[1][0], 2)]; // Calculate x and y axis values across the specfied number of steps.\n\n  var yAxis = [];\n  var y = bounds[1][1]; // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n\n  var yStepInterval = round(dimensions[1] / steps[1], 4);\n\n  while (round(y, 2) >= bounds[1][0]) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n\n  var xAxis = [];\n  var x = bounds[0][0];\n  var xStepInterval = dimensions[0] / steps[0];\n\n  while (xStepInterval > 0 && x <= bounds[0][1] || xStepInterval < 0 && x >= bounds[0][1]) {\n    xAxis.push(x);\n    x += xStepInterval;\n  }\n\n  var _options3 = options,\n      thickness = _options3.thickness;\n\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (calcValues.length < 5) {\n      thickness = 'xlarge';\n    } else if (calcValues.length < 11) {\n      thickness = 'large';\n    } else if (calcValues.length < 21) {\n      thickness = 'medium';\n    } else if (calcValues.length < 61) {\n      thickness = 'small';\n    } else if (calcValues.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n\n  var pad = thicknessPad[thickness];\n  return {\n    axis: [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};","map":{"version":3,"sources":["/Users/tessie/Documents/mediary-graphql/client/node_modules/grommet/es6/components/Chart/calcs.js"],"names":["normalizeValues","thicknessPad","xlarge","large","medium","small","xsmall","round","value","decimals","Number","Math","calcs","values","options","coarseness","steps","calcValues","min","max","length","filter","undefined","forEach","y","y2","delta","interval","parseFloat","toPrecision","abs","stepInterval","minSteps","maxSteps","floor","ceil","_options","_options2","bounds","dimensions","yAxis","yStepInterval","push","xAxis","x","xStepInterval","_options3","thickness","pad","axis"],"mappings":"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","sourcesContent":["import { normalizeValues } from './utils';\nvar thicknessPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall'\n};\nexport var round = function round(value, decimals) {\n  return Number(Math.round(value + \"e\" + decimals) + \"e-\" + decimals);\n};\nexport var calcs = function calcs(values, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // coarseness influences the rounding of the bounds, the smaller the\n  // number, the more the bounds will be rounded. e.g. 111 -> 110 -> 100\n  var coarseness = options.coarseness || 5; // the number of steps is one less than the number of labels\n\n  var steps = options.steps || [1, 1];\n  var calcValues = normalizeValues(values || []); // min and max y values\n\n  var min;\n  var max;\n\n  if (calcValues.length) {\n    // Calculate the max and min y values.\n    calcValues.filter(function (value) {\n      return value !== undefined;\n    }).forEach(function (value) {\n      var y = value.value[1];\n\n      if (y !== undefined) {\n        min = min === undefined ? y : Math.min(min, y);\n        max = max === undefined ? y : Math.max(max, y);\n      } // handle ranges of values\n\n\n      var y2 = value.value[2];\n\n      if (y2 !== undefined) {\n        min = Math.min(min, y2);\n        max = Math.max(max, y2);\n      }\n    }); // when max === min, offset them so we can show something\n\n    if (max === min) {\n      if (max > 0) min = max - 1;else max = min + 1;\n    } // Calculate some reasonable y bounds based on the max and min y values.\n    // This is so values like 87342.12 don't end up being displayed as the\n    // graph axis edge label.\n\n\n    var delta = max - min;\n    var interval = Number.parseFloat((delta / coarseness).toPrecision(1));\n    max = max - max % interval + interval;\n    min -= min % interval;\n\n    if (min < 0 && max > 0 && Math.abs(min) !== Math.abs(max)) {\n      // Adjust min and max when crossing 0 to ensure 0 will be shown on\n      // the Y axis based on the number of steps.\n      // const ratio = Math.abs(max) / Math.abs(min);\n      var stepInterval = (max - min) / steps[1];\n      var minSteps = min / stepInterval;\n      var maxSteps = max / stepInterval;\n\n      if (Math.abs(minSteps) < Math.abs(maxSteps)) {\n        stepInterval = max / Math.floor(maxSteps);\n        max = stepInterval * Math.floor(maxSteps);\n        min = stepInterval * Math.floor(minSteps);\n      } else {\n        stepInterval = Math.abs(min / Math.ceil(minSteps));\n        min = stepInterval * Math.ceil(minSteps);\n        max = stepInterval * Math.ceil(maxSteps);\n      }\n    }\n  }\n\n  if (options.min !== undefined) {\n    var _options = options;\n    min = _options.min;\n  }\n\n  if (options.max !== undefined) {\n    var _options2 = options;\n    max = _options2.max;\n  }\n\n  var bounds;\n  if (calcValues.length > 1) bounds = [[calcValues[0].value[0], calcValues[calcValues.length - 1].value[0]], [min, max]];else if (calcValues.length === 1) // when we only have one value, at least git some x bounds\n    bounds = [[calcValues[0].value[0], calcValues[0].value[0] + 1], [min, max]];else bounds = [[], []];\n  var dimensions = [round(bounds[0][1] - bounds[0][0], 2), round(bounds[1][1] - bounds[1][0], 2)]; // Calculate x and y axis values across the specfied number of steps.\n\n  var yAxis = [];\n  var y = bounds[1][1]; // To deal with javascript math limitations, round the step with 4 decimal\n  // places and then push the values with 2 decimal places\n\n  var yStepInterval = round(dimensions[1] / steps[1], 4);\n\n  while (round(y, 2) >= bounds[1][0]) {\n    yAxis.push(round(y, 2));\n    y -= yStepInterval;\n  }\n\n  var xAxis = [];\n  var x = bounds[0][0];\n  var xStepInterval = dimensions[0] / steps[0];\n\n  while (xStepInterval > 0 && x <= bounds[0][1] || xStepInterval < 0 && x >= bounds[0][1]) {\n    xAxis.push(x);\n    x += xStepInterval;\n  }\n\n  var _options3 = options,\n      thickness = _options3.thickness;\n\n  if (!thickness) {\n    // Set bar thickness based on number of values being rendered.\n    // Someday, it would be better to include the actual rendered size.\n    // These values were emirically determined, trying to balance visibility\n    // and overlap across resolutions.\n    if (calcValues.length < 5) {\n      thickness = 'xlarge';\n    } else if (calcValues.length < 11) {\n      thickness = 'large';\n    } else if (calcValues.length < 21) {\n      thickness = 'medium';\n    } else if (calcValues.length < 61) {\n      thickness = 'small';\n    } else if (calcValues.length < 121) {\n      thickness = 'xsmall';\n    } else {\n      thickness = 'hair';\n    }\n  }\n\n  var pad = thicknessPad[thickness];\n  return {\n    axis: [xAxis, yAxis],\n    bounds: bounds,\n    dimensions: dimensions,\n    pad: pad,\n    thickness: thickness\n  };\n};"]},"metadata":{},"sourceType":"module"}