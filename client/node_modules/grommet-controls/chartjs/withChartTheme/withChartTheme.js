var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { ThemeContext } from 'grommet';
import { normalizeColor, getRGBA } from 'grommet/utils/colors';
import { deepMerge } from 'grommet/utils/object';
import { colorFromIndex, colorForName } from '../../utils/colors';
var normalizedColor = function (color, theme) { return (colorForName(normalizeColor(color, theme), theme)); };
// eslint-disable-next-line import/prefer-default-export
export var withChartTheme = function (WrappedComponent, _a) {
    if (_a === void 0) { _a = {}; }
    var _b = _a.classOpacity, classOpacity = _b === void 0 ? 0.6 : _b, _c = _a.defaultScales, defaultScales = _c === void 0 ? [{}] : _c, other = __rest(_a, ["classOpacity", "defaultScales"]);
    return function (_a) {
        var options = _a.options, data = _a.data;
        return (React.createElement(ThemeContext.Consumer, null, function (theme) {
            var textColor = normalizedColor('text', theme);
            var axisColors = {
                ticks: {
                    fontColor: textColor,
                },
                gridLines: {
                    color: normalizedColor('border', theme),
                },
                scaleLabel: {
                    fontColor: textColor,
                },
            };
            var defaultOptions = {
                maintainAspectRatio: false,
                title: {
                    fontColor: textColor,
                },
                legend: {
                    labels: {
                        fontColor: textColor,
                    },
                },
                scales: {},
            };
            var themedOptions = deepMerge(defaultOptions, options);
            themedOptions.scales.xAxes = themedOptions.scales.xAxes || defaultScales;
            themedOptions.scales.yAxes = themedOptions.scales.yAxes || defaultScales;
            themedOptions.scales.xAxes = themedOptions.scales.xAxes.map(function (x) { return deepMerge(axisColors, x); });
            themedOptions.scales.yAxes = themedOptions.scales.yAxes.map(function (y) { return deepMerge(axisColors, y); });
            var datasets;
            if (data && Array.isArray(data.datasets)) {
                datasets = data.datasets
                    .map(function (dataset, i) {
                    var backgroundColor = dataset.backgroundColor, borderColor = dataset.borderColor, color = dataset.color, rest = __rest(dataset, ["backgroundColor", "borderColor", "color"]);
                    var newOpts;
                    var themeColors = function (index, itemOpacity) {
                        var lineColor = borderColor || color || colorFromIndex(index);
                        var lineColors = Array.isArray(lineColor)
                            ? lineColor.map(function (c) { return normalizedColor(c, theme); }) : normalizedColor(lineColor, theme);
                        var fillColor = backgroundColor || lineColor;
                        var opacity = itemOpacity || dataset.opacity
                            || (options && options.opacity) || classOpacity;
                        var fillColors = Array.isArray(fillColor)
                            ? fillColor.map(function (c) { return getRGBA(normalizedColor(c, theme), opacity); })
                            : getRGBA(normalizedColor(fillColor, theme), opacity);
                        return {
                            backgroundColor: fillColors,
                            borderColor: lineColors,
                        };
                    };
                    if (options && options.themedData && dataset.data) {
                        newOpts = { backgroundColor: [], borderColor: [] };
                        dataset.data.forEach(function (dataRow, rIndex) {
                            var colors = themeColors(rIndex, dataRow.opacity);
                            newOpts.backgroundColor.push(colors.backgroundColor);
                            newOpts.borderColor.push(colors.borderColor);
                        });
                    }
                    else {
                        newOpts = themeColors(i);
                    }
                    return __assign(__assign(__assign({}, newOpts), other), rest);
                });
            }
            return (React.createElement(WrappedComponent, { options: themedOptions, data: __assign(__assign({}, data), { datasets: datasets }) }));
        }));
    };
};
