var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import { ThemeContext } from 'styled-components';
import { Box, Keyboard } from 'grommet';
import { normalizeColor } from 'grommet/utils/colors';
import { parseMetricToNum } from 'grommet/utils/mixins';
import { StyledColors, StyledColor, StyledColorContainer, StyledRow, StyledRows, } from './StyledColors';
var buildState = function (props) {
    var colors = props.colors, color = props.color, columns = props.columns, wrap = props.wrap;
    var colorRows = [];
    var lastRow = null;
    if (colors) {
        Object.keys(colors).forEach(function (item) {
            if (typeof colors[item] === 'object') {
                var row_1 = { name: item, colors: [], buttonRef: React.createRef() };
                Object.keys(colors[item]).forEach(function (colorName) {
                    var colorsColor = colors[item][colorName];
                    row_1.colors.push({ name: colorName, color: colorsColor });
                });
                colorRows.push(row_1);
            }
            else {
                if (!lastRow) {
                    lastRow = { name: undefined, colors: [] };
                    colorRows.push(lastRow);
                }
                lastRow.colors.push({ name: item, color: colors[item], buttonRef: React.createRef() });
            }
        });
    }
    var colorsPerRow = columns
        || (colorRows.length === 1 ? Math.sqrt(colorRows[0].colors.length)
            : colorRows.reduce(function (res, row) { return (Math.min(res, row.colors.length)); }, Number.MAX_SAFE_INTEGER));
    var wrapColors = wrap;
    if (wrapColors === undefined) {
        wrapColors = columns === undefined && colorRows.length === 1;
    }
    if (wrapColors) {
        var finalRows_1 = [];
        colorRows.forEach(function (row) {
            while (row.colors.length > 0) {
                finalRows_1.push({ name: row.name, colors: row.colors.splice(0, colorsPerRow) });
            }
        });
        colorRows = finalRows_1;
    }
    else {
        colorRows = colorRows.map(function (row) { return (__assign(__assign({}, row), { colors: row.colors.filter(function (_, index) { return (index < colorsPerRow); }) })); });
    }
    var activeRow = 0;
    var activeColor = 0;
    colorRows.find(function (row, rowIndex) { return row.colors.find(function (item, colorIndex) {
        var found = item.color === color;
        if (found) {
            activeRow = rowIndex;
            activeColor = colorIndex;
        }
        return found;
    }); });
    return { colorRows: colorRows, activeRow: activeRow, activeColor: activeColor };
};
/** A color selection element, with custom color palettes.<br/>
*`import { Colors } from 'grommet-controls';`<br/>
*`<Colors colors={...} />`<br/>
*/
var Colors = /** @class */ (function (_super) {
    __extends(Colors, _super);
    function Colors(props) {
        var _this = _super.call(this, props) || this;
        _this.setFocus = false;
        _this.timer = 0;
        _this.setActive = function (_a) {
            var rowIndex = _a.rowIndex, colorIndex = _a.colorIndex;
            var colorRows = _this.state.colorRows;
            _this.setFocus = true;
            var activeRow = Math.min(Math.max(0, rowIndex), colorRows.length - 1);
            var color = Math.max(0, colorIndex);
            var activeColor = Math.min(color, colorRows[activeRow].colors.length - 1);
            _this.setState({
                activeRow: activeRow,
                activeColor: activeColor,
            });
        };
        _this.onClickColor = function (_a) {
            var color = _a.color, rowIndex = _a.rowIndex, colorIndex = _a.colorIndex, rowName = _a.rowName, colorName = _a.colorName;
            return function () {
                var onSelect = _this.props.onSelect;
                _this.setActive({ rowIndex: rowIndex, colorIndex: colorIndex });
                if (onSelect) {
                    onSelect({ color: color, rowName: rowName, colorName: colorName });
                }
            };
        };
        _this.state = buildState(props);
        return _this;
    }
    Colors.getDerivedStateFromProps = function (nextProps) {
        return buildState(nextProps);
    };
    Colors.prototype.componentDidUpdate = function () {
        if (this.setFocus) {
            var _a = this.state, activeRow = _a.activeRow, activeColor = _a.activeColor, colorRows = _a.colorRows;
            this.setFocus = false;
            if (colorRows[activeRow]
                && colorRows[activeRow].colors[activeColor]
                && colorRows[activeRow].colors[activeColor].buttonRef) {
                var buttonNode = findDOMNode(colorRows[activeRow].colors[activeColor].buttonRef.current);
                if (buttonNode) {
                    buttonNode.scrollIntoView();
                    buttonNode.focus();
                }
            }
        }
    };
    Colors.prototype.componentWillUnmount = function () {
        clearTimeout(this.timer);
    };
    Colors.prototype.render = function () {
        var _this = this;
        var _a = this.props, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        wrap = _a.wrap, onSelect = _a.onSelect, columns = _a.columns, size = _a.size, rest = __rest(_a, ["wrap", "onSelect", "columns", "size"]);
        var _b = this.state, colorRows = _b.colorRows, activeRow = _b.activeRow, activeColor = _b.activeColor;
        var colors = function (theme, cellSize) { return (colorRows.map(function (row, rowIndex) { return (React.createElement(StyledRow, { key: "row_" + rowIndex, theme: theme, style: { width: cellSize * row.colors.length + "px", height: cellSize + "px" } }, row.colors.map(function (color, colorIndex) {
            var isActive = activeRow === rowIndex && activeColor === colorIndex;
            var colorStyle = {
                backgroundColor: color.color,
                color: normalizeColor('text', theme),
                left: cellSize * colorIndex + "px",
            };
            return (React.createElement(StyledColorContainer, { key: "color_" + colorIndex, theme: theme },
                React.createElement(StyledColor
                // eslint-disable-next-line no-param-reassign
                , { 
                    // eslint-disable-next-line no-param-reassign
                    ref: color.buttonRef, style: colorStyle, size: size, theme: theme, tabIndex: isActive ? 0 : -1, a11yTitle: (row.name !== undefined ? row.name : '') + " " + color.name, plain: true, active: isActive, hoverIndicator: 'background', onClick: _this.onClickColor({
                        color: color.color,
                        rowIndex: rowIndex,
                        colorIndex: colorIndex,
                        colorName: color.name,
                        rowName: row.name,
                    }) },
                    React.createElement("span", null, color.color))));
        }))); })); };
        return (React.createElement(ThemeContext.Consumer, null, function (theme) {
            var cellSize = parseMetricToNum(theme.calendar[size].daySize);
            return (React.createElement(StyledColors, __assign({ size: size, theme: theme }, rest),
                React.createElement(Keyboard, { onUp: function (event) {
                        event.preventDefault();
                        _this.setActive({ rowIndex: activeRow - 1, colorIndex: activeColor });
                    }, onDown: function (event) {
                        event.preventDefault();
                        _this.setActive({ rowIndex: activeRow + 1, colorIndex: activeColor });
                    }, onLeft: function () { return _this.setActive({ rowIndex: activeRow, colorIndex: activeColor - 1 }); }, onRight: function () { return _this.setActive({ rowIndex: activeRow, colorIndex: activeColor + 1 }); } },
                    React.createElement(Box, null,
                        React.createElement(StyledRows, { style: { height: cellSize * colorRows.length + "px" } }, colors(theme, cellSize))))));
        }));
    };
    Colors.defaultProps = {
        size: 'medium',
    };
    return Colors;
}(Component));
export { Colors };
