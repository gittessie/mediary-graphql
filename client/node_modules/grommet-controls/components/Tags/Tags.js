var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import { Box, Keyboard, Text, } from 'grommet';
import { FormClose } from 'grommet-icons/icons/FormClose';
import { Tag } from '../Tag';
export var TagsSelect = function (props) {
    var _a = props || { tagProps: {} }, tagProps = _a.tagProps, rest = __rest(_a, ["tagProps"]);
    return function (_a) {
        var placeholder = _a.placeholder, value = _a.value, onChange = _a.onChange;
        return (React.createElement(Tags, __assign({ focusable: false, placeholder: placeholder, value: value, onChange: onChange, tagProps: __assign(__assign({}, tagProps), { onClick: function (e) { return e.stopPropagation(); } }) }, rest)));
    };
};
/**
 * A list of tags that can be removed<b/>
 * `import { Tags } from 'grommet-controls';`<b/>
 * `<Tags />`<b/>
 */
var Tags = /** @class */ (function (_super) {
    __extends(Tags, _super);
    function Tags() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            selectedTagIndex: -1,
        };
        _this.tagRefs = [];
        _this.elementRef = React.createRef();
        _this.selectTag = function (selected) {
            var _a = _this.props, onChange = _a.onChange, value = _a.value;
            if (onChange) {
                var tags = selected;
                if (Array.isArray(value)) {
                    var index = value.indexOf(tags);
                    if (index !== -1) {
                        tags = value.filter(function (item) { return item !== selected; });
                    }
                    else {
                        tags = __spreadArrays(value, [tags]);
                    }
                }
                else {
                    tags = [tags];
                }
                onChange({ target: findDOMNode(_this.elementRef.current), option: selected, value: tags });
            }
        };
        _this.onNextTag = function (event) {
            var value = _this.props.value;
            var selectedTagIndex = _this.state.selectedTagIndex;
            event.preventDefault();
            var index = selectedTagIndex + 1;
            if (index >= value.length) {
                index = 0;
            }
            _this.focusTag(index);
        };
        _this.onPreviousTag = function (event) {
            var selectedTagIndex = _this.state.selectedTagIndex;
            var value = _this.props.value;
            event.preventDefault();
            var index = selectedTagIndex - 1;
            if (index < 0) {
                index = value.length - 1;
            }
            _this.focusTag(index);
        };
        _this.onSelectTag = function (event) {
            var value = _this.props.value;
            var selectedTagIndex = _this.state.selectedTagIndex;
            if (selectedTagIndex >= 0 && selectedTagIndex < value.length) {
                event.preventDefault(); // prevent submitting forms
                event.stopPropagation();
                _this.selectTag(value[selectedTagIndex]);
            }
        };
        _this.onCloseClick = function (e, tag) {
            e.stopPropagation();
            _this.selectTag(tag);
        };
        return _this;
    }
    Tags.prototype.focusTag = function (index) {
        if (index >= 0 && index < this.tagRefs.length) {
            var tagElement = findDOMNode(this.tagRefs[index].current);
            if (tagElement && typeof tagElement.focus === 'function') {
                tagElement.focus();
            }
            this.setState({ selectedTagIndex: index });
        }
    };
    Tags.prototype.render = function () {
        var _this = this;
        var _a = this.props, placeholder = _a.placeholder, children = _a.children, value = _a.value, onChange = _a.onChange, focusable = _a.focusable, onClick = _a.onClick, direction = _a.direction, icon = _a.icon, tagProps = _a.tagProps, rest = __rest(_a, ["placeholder", "children", "value", "onChange", "focusable", "onClick", "direction", "icon", "tagProps"]);
        var noValues;
        if ((!value || (Array.isArray(value) && value.length === 0))) {
            noValues = React.isValidElement(placeholder) ? placeholder : (
            // placeholder. minimum height of icon to keep size
            React.createElement(Text, { color: 'placeholder', style: { minHeight: '24px' } }, placeholder || 'No selection'));
        }
        var values;
        if (Array.isArray(value)) {
            values = value;
        }
        else {
            values = value ? [value] : [];
        }
        return (React.createElement(Keyboard, { onEnter: this.onSelectTag, onSpace: this.onSelectTag, onLeft: this.onPreviousTag, onRight: this.onNextTag },
            React.createElement(Box, __assign({ tabIndex: focusable ? 0 : undefined, ref: this.elementRef, direction: direction, overflow: 'auto', style: { minWidth: 'auto' } }, rest), noValues || values.map(function (tag, index) {
                if (children) {
                    return children(tag, index, value);
                }
                if (!_this.tagRefs[index]) {
                    _this.tagRefs[index] = React.createRef();
                }
                return (React.createElement(Tag, __assign({ key: "tag_" + tag + "_" + index, ariaChecked: true, a11yTitle: "Remove " + tag.toString(), label: typeof tag !== 'object' ? tag.toString() : undefined, ref: _this.tagRefs[index], onClick: onClick ? function (e) { return onClick(e, tag); } : undefined, onChange: onChange ? function (e) { return _this.onCloseClick(e, tag); } : undefined, icon: icon }, (typeof tag === 'object' ? __assign(__assign({}, tagProps), tag) : tagProps))));
            }))));
    };
    Tags.defaultProps = {
        pad: 'small',
        focusable: true,
        margin: { horizontal: 'xsmall', vertical: 'small' },
        value: [],
        gap: 'xsmall',
        direction: 'row-responsive',
        icon: React.createElement(FormClose, null),
    };
    return Tags;
}(Component));
export { Tags };
