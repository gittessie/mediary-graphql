var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
/* eslint-disable no-nested-ternary,no-shadow,no-param-reassign,
prefer-destructuring,no-mixed-operators */
import React, { Component } from 'react';
import _ from './utils';
import defaultProps from './defaultProps';
import { focusNextElement, focusPrevElement } from '../DOM';
var ReactTable = /** @class */ (function (_super) {
    __extends(ReactTable, _super);
    function ReactTable(props) {
        var _this = _super.call(this, props) || this;
        _this.rowRef = [];
        _this.footerRef = null;
        _this.filterRef = null;
        _this.headerRef = null;
        _this.headerGroupsRef = null;
        _this.getResolvedState = function (props, state) { return (__assign(__assign(__assign(__assign({}, _.compactObject(_this.state)), _.compactObject(_this.props)), _.compactObject(state)), _.compactObject(props))); };
        _this.fireFetchData = function () {
            _this.props.onFetchData(_this.getResolvedState(), _this);
        };
        _this.getStateOrProp = function (key) { return _.getFirstDefined(_this.state[key], _this.props[key]); };
        _this.getMinRows = function () { return _.getFirstDefined(_this.props.minRows, _this.getStateOrProp('pageSize')); };
        // User actions
        _this.onPageChange = function (page) {
            var _a = _this.props, onPageChange = _a.onPageChange, collapseOnPageChange = _a.collapseOnPageChange;
            var newState = { page: page };
            if (collapseOnPageChange) {
                newState.expanded = {};
            }
            _this.setStateWithData(newState, _this.state, _this.props, function () { return (onPageChange && onPageChange(page)); });
        };
        _this.onPageSizeChange = function (newPageSize) {
            var onPageSizeChange = _this.props.onPageSizeChange;
            var _a = _this.getResolvedState(), pageSize = _a.pageSize, page = _a.page;
            // Normalize the page to display
            var currentRow = pageSize * page;
            var newPage = Math.floor(currentRow / newPageSize);
            _this.setStateWithData({
                pageSize: newPageSize,
                page: newPage,
            }, _this.state, _this.props, function () { return (onPageSizeChange && onPageSizeChange(newPageSize, newPage)); });
        };
        _this.sortColumn = function (column, additive) {
            var _a = _this.getResolvedState(), sorted = _a.sorted, skipNextSort = _a.skipNextSort, defaultSortDesc = _a.defaultSortDesc;
            var firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc')
                ? column.defaultSortDesc
                : defaultSortDesc;
            var secondSortDirection = !firstSortDirection;
            // we can't stop event propagation from the column resize move handlers
            // attached to the document because of react's synthetic events
            // so we have to prevent the sort function from actually sorting
            // if we click on the column resize element within a header.
            if (skipNextSort) {
                _this.setStateWithData({
                    skipNextSort: false,
                }, _this.state, _this.props);
                return;
            }
            var onSortedChange = _this.props.onSortedChange;
            var newSorted = _.clone(sorted || []).map(function (d) {
                d.desc = _.isSortingDesc(d);
                return d;
            });
            if (!_.isArray(column)) {
                // Single-Sort
                var existingIndex = newSorted.findIndex(function (d) { return d.id === column.id; });
                if (existingIndex > -1) {
                    var existing = newSorted[existingIndex];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex, 1);
                        }
                        else {
                            existing.desc = firstSortDirection;
                            newSorted = [existing];
                        }
                    }
                    else {
                        existing.desc = secondSortDirection;
                        if (!additive) {
                            newSorted = [existing];
                        }
                    }
                }
                else if (additive) {
                    newSorted.push({
                        id: column.id,
                        desc: firstSortDirection,
                    });
                }
                else {
                    newSorted = [
                        {
                            id: column.id,
                            desc: firstSortDirection,
                        },
                    ];
                }
            }
            else {
                // Multi-Sort
                var existingIndex_1 = newSorted.findIndex(function (d) { return d.id === column[0].id; });
                // Existing Sorted Column
                if (existingIndex_1 > -1) {
                    var existing = newSorted[existingIndex_1];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex_1, column.length);
                        }
                        else {
                            column.forEach(function (_d, i) {
                                newSorted[existingIndex_1 + i].desc = firstSortDirection;
                            });
                        }
                    }
                    else {
                        column.forEach(function (_d, i) {
                            newSorted[existingIndex_1 + i].desc = secondSortDirection;
                        });
                    }
                    if (!additive) {
                        newSorted = newSorted.slice(existingIndex_1, column.length);
                    }
                    // New Sort Column
                }
                else if (additive) {
                    newSorted = newSorted.concat(column.map(function (d) { return ({
                        id: d.id,
                        desc: firstSortDirection,
                    }); }));
                }
                else {
                    newSorted = column.map(function (d) { return ({
                        id: d.id,
                        desc: firstSortDirection,
                    }); });
                }
            }
            _this.setStateWithData({
                page: (!sorted.length && newSorted.length) || !additive
                    ? 0
                    : _this.state.page,
                sorted: newSorted,
            }, _this.state, _this.props, function () { return (onSortedChange && onSortedChange(newSorted, column, additive)); });
        };
        _this.filterColumn = function (column, value) {
            var filtered = _this.getResolvedState().filtered;
            var onFilteredChange = _this.props.onFilteredChange;
            // Remove old filter first if it exists
            var newFiltering = (filtered || []).filter(function (x) { return (x.id !== column.id); });
            if (value !== '') {
                newFiltering.push({
                    id: column.id,
                    value: value,
                });
            }
            _this.setStateWithData({
                filtered: newFiltering,
            }, _this.state, _this.props, function () { return (onFilteredChange && onFilteredChange(newFiltering, column, value)); });
        };
        _this.resizeColumnStart = function (event, column, isTouch) {
            event.stopPropagation();
            var parentWidth = event.target.parentElement.getBoundingClientRect()
                .width;
            var pageX;
            if (isTouch) {
                pageX = event.changedTouches[0].pageX;
            }
            else {
                pageX = event.pageX;
            }
            _this.setStateWithData({
                currentlyResizing: {
                    id: column.id,
                    startX: pageX,
                    parentWidth: parentWidth,
                },
            }, _this.state, _this.props, function () {
                if (isTouch) {
                    document.addEventListener('touchmove', _this.resizeColumnMoving);
                    document.addEventListener('touchcancel', _this.resizeColumnEnd);
                    document.addEventListener('touchend', _this.resizeColumnEnd);
                }
                else {
                    document.addEventListener('mousemove', _this.resizeColumnMoving);
                    document.addEventListener('mouseup', _this.resizeColumnEnd);
                    document.addEventListener('mouseleave', _this.resizeColumnEnd);
                }
            });
        };
        _this.resizeColumnMoving = function (event) {
            event.stopPropagation();
            var onResizedChange = _this.props.onResizedChange;
            var _a = _this.getResolvedState(), resized = _a.resized, currentlyResizing = _a.currentlyResizing;
            // Delete old value
            var newResized = resized.filter(function (x) { return x.id !== currentlyResizing.id; });
            var pageX;
            if (event.type === 'touchmove') {
                pageX = event.changedTouches[0].pageX;
            }
            else if (event.type === 'mousemove') {
                pageX = event.pageX;
            }
            // Set the min size to 10 to account for margin and border or else the
            // group headers don't line up correctly
            var newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, 11);
            newResized.push({
                id: currentlyResizing.id,
                value: newWidth,
            });
            _this.setStateWithData({
                resized: newResized,
            }, _this.state, _this.props, function () { return (onResizedChange && onResizedChange(newResized, event)); });
        };
        _this.resizeColumnEnd = function (event) {
            event.stopPropagation();
            var isTouch = event.type === 'touchend' || event.type === 'touchcancel';
            if (isTouch) {
                document.removeEventListener('touchmove', _this.resizeColumnMoving);
                document.removeEventListener('touchcancel', _this.resizeColumnEnd);
                document.removeEventListener('touchend', _this.resizeColumnEnd);
            }
            // If its a touch event clear the mouse one's as well because sometimes
            // the mouseDown event gets called as well, but the mouseUp event doesn't
            document.removeEventListener('mousemove', _this.resizeColumnMoving);
            document.removeEventListener('mouseup', _this.resizeColumnEnd);
            document.removeEventListener('mouseleave', _this.resizeColumnEnd);
            // The touch events don't propagate up to the sorting's onMouseDown event so
            // no need to prevent it from happening or else the first click after a touch
            // event resize will not sort the column.
            if (!isTouch) {
                _this.setStateWithData({
                    skipNextSort: true,
                    currentlyResizing: undefined,
                }, _this.state, _this.props);
            }
        };
        _this.rowRef = [];
        _this.state = {
            page: 0,
            pageSize: props.defaultPageSize,
            sorted: props.defaultSorted,
            expanded: props.defaultExpanded,
            filtered: props.defaultFiltered,
            resized: props.defaultResized,
            currentlyResizing: undefined,
            skipNextSort: false,
        };
        return _this;
    }
    ReactTable.prototype.componentDidMount = function () {
        this.fireFetchData();
    };
    ReactTable.getDerivedStateFromProps = function (nextProps, oldState) {
        var newState = __assign(__assign({}, oldState), nextProps);
        // Do a deep compare of new and old `defaultOption` and
        // if they are different reset `option = defaultOption`
        var defaultableOptions = ['sorted', 'filtered', 'resized', 'expanded'];
        defaultableOptions.forEach(function (x) {
            var defaultName = "default" + (x.charAt(0).toUpperCase() + x.slice(1));
            if (JSON.stringify(oldState[defaultName])
                !== JSON.stringify(newState[defaultName])) {
                newState[x] = newState[defaultName];
            }
        });
        // If they change these table options, we need to reset defaults
        // or else we could get into a state where the user has changed the UI
        // and then disabled the ability to change it back.
        // e.g. If `filterable` has changed, set `filtered = defaultFiltered`
        var resettableOptions = ['sortable', 'filterable', 'resizable'];
        resettableOptions.forEach(function (x) {
            if (oldState[x] !== newState[x]) {
                var baseName = x.replace('able', '');
                var optionName = baseName + "ed";
                var defaultName = "default" + (optionName.charAt(0).toUpperCase()
                    + optionName.slice(1));
                newState[optionName] = newState[defaultName];
            }
        });
        // Props that trigger a data update
        if (oldState.data !== newState.data
            || JSON.stringify(oldState.columns) !== JSON.stringify(newState.columns)
            || oldState.pivotBy !== newState.pivotBy
            || oldState.sorted !== newState.sorted
            || oldState.filtered !== newState.filtered) {
            return ReactTable.getStateWithData(ReactTable.getDataModel(newState, nextProps), oldState, nextProps);
        }
        return null;
    };
    ReactTable.getStateWithData = function (newState, oldState, props) {
        var newResolvedState = __assign(__assign(__assign({}, oldState), newState), props);
        var freezeWhenExpanded = newResolvedState.freezeWhenExpanded;
        // Default to unfrozen state
        newResolvedState.frozen = false;
        // If freezeWhenExpanded is set, check for frozen conditions
        if (freezeWhenExpanded) {
            // if any rows are expanded, freeze the existing data and sorting
            var keys = Object.keys(newResolvedState.expanded);
            for (var i = 0; i < keys.length; i += 1) {
                if (newResolvedState.expanded[keys[i]]) {
                    newResolvedState.frozen = true;
                    break;
                }
            }
        }
        // If the data isn't frozen and either the data or
        // sorting model has changed, update the data
        if ((oldState.frozen && !newResolvedState.frozen)
            || oldState.sorted !== newResolvedState.sorted
            || oldState.filtered !== newResolvedState.filtered
            || oldState.showFilters !== newResolvedState.showFilters
            || (!newResolvedState.frozen
                && oldState.resolvedData !== newResolvedState.resolvedData)) {
            // Handle collapseOnsortedChange & collapseOnDataChange
            if ((oldState.sorted !== newResolvedState.sorted
                && props.collapseOnSortingChange)
                || oldState.filtered !== newResolvedState.filtered
                || oldState.showFilters !== newResolvedState.showFilters
                || (oldState.sortedData
                    && !newResolvedState.frozen
                    && oldState.resolvedData !== newResolvedState.resolvedData
                    && props.collapseOnDataChange)) {
                newResolvedState.expanded = {};
            }
            Object.assign(newResolvedState, ReactTable.getSortedData(newResolvedState, props));
        }
        // Set page to 0 if filters change
        if (oldState.filtered !== newResolvedState.filtered) {
            newResolvedState.page = 0;
        }
        // Calculate pageSize all the time
        if (newResolvedState.sortedData) {
            newResolvedState.pages = newResolvedState.manual
                ? newResolvedState.pages
                : Math.ceil(newResolvedState.sortedData.length / newResolvedState.pageSize);
            newResolvedState.page = Math.max(newResolvedState.page >= newResolvedState.pages
                ? newResolvedState.pages - 1
                : newResolvedState.page, 0);
        }
        return newResolvedState;
    };
    ReactTable.prototype.setStateWithData = function (newState, oldState, props, cb) {
        var _this = this;
        var newResolvedState = ReactTable.getStateWithData(newState, oldState, props);
        return this.setState(newResolvedState, function () {
            if (cb) {
                cb();
            }
            if (oldState.page !== newResolvedState.page
                || oldState.pageSize !== newResolvedState.pageSize
                || oldState.sorted !== newResolvedState.sorted
                || oldState.filtered !== newResolvedState.filtered) {
                _this.fireFetchData();
            }
        });
    };
    ReactTable.prototype.render = function () {
        var _this = this;
        var resolvedState = this.getResolvedState();
        var getProps = resolvedState.getProps, getTableProps = resolvedState.getTableProps, getTheadGroupProps = resolvedState.getTheadGroupProps, getTheadGroupTrProps = resolvedState.getTheadGroupTrProps, getTheadProps = resolvedState.getTheadProps, getTheadTrProps = resolvedState.getTheadTrProps, getTheadThProps = resolvedState.getTheadThProps, getTheadFilterProps = resolvedState.getTheadFilterProps, getTheadFilterTrProps = resolvedState.getTheadFilterTrProps, getTheadFilterThProps = resolvedState.getTheadFilterThProps, getFilterInputProps = resolvedState.getFilterInputProps, getTbodyProps = resolvedState.getTbodyProps, getTrGroupProps = resolvedState.getTrGroupProps, getTrProps = resolvedState.getTrProps, getTdProps = resolvedState.getTdProps, getExpanderProps = resolvedState.getExpanderProps, getTfootProps = resolvedState.getTfootProps, getTfootTrProps = resolvedState.getTfootTrProps, getTfootTdProps = resolvedState.getTfootTdProps, getPaginationProps = resolvedState.getPaginationProps, getLoadingProps = resolvedState.getLoadingProps, getNoDataProps = resolvedState.getNoDataProps, getResizerProps = resolvedState.getResizerProps, showPagination = resolvedState.showPagination, showPaginationTop = resolvedState.showPaginationTop, showPaginationBottom = resolvedState.showPaginationBottom, manual = resolvedState.manual, loadingText = resolvedState.loadingText, noDataText = resolvedState.noDataText, sortable = resolvedState.sortable, multiSort = resolvedState.multiSort, resizable = resolvedState.resizable, filterable = resolvedState.filterable, 
        // Pivoting State
        pivotIDKey = resolvedState.pivotIDKey, pivotValKey = resolvedState.pivotValKey, pivotBy = resolvedState.pivotBy, subRowsKey = resolvedState.subRowsKey, aggregatedKey = resolvedState.aggregatedKey, originalKey = resolvedState.originalKey, indexKey = resolvedState.indexKey, groupedByPivotKey = resolvedState.groupedByPivotKey, expanderTdDefaultProps = resolvedState.expanderTdDefaultProps, 
        // State
        loading = resolvedState.loading, pageSize = resolvedState.pageSize, page = resolvedState.page, sorted = resolvedState.sorted, filtered = resolvedState.filtered, resized = resolvedState.resized, expanded = resolvedState.expanded, pages = resolvedState.pages, onExpandedChange = resolvedState.onExpandedChange, 
        // Components
        TableComponent = resolvedState.TableComponent, TheadComponent = resolvedState.TheadComponent, TbodyComponent = resolvedState.TbodyComponent, TrGroupComponent = resolvedState.TrGroupComponent, TrComponent = resolvedState.TrComponent, ThComponent = resolvedState.ThComponent, TdComponent = resolvedState.TdComponent, CellTextComponent = resolvedState.CellTextComponent, TfootComponent = resolvedState.TfootComponent, PaginationComponent = resolvedState.PaginationComponent, LoadingComponent = resolvedState.LoadingComponent, SubComponent = resolvedState.SubComponent, NoDataComponent = resolvedState.NoDataComponent, ResizerComponent = resolvedState.ResizerComponent, ExpanderComponent = resolvedState.ExpanderComponent, PivotValueComponent = resolvedState.PivotValueComponent, PivotComponent = resolvedState.PivotComponent, AggregatedComponent = resolvedState.AggregatedComponent, FilterComponent = resolvedState.FilterComponent, PadRowComponent = resolvedState.PadRowComponent, 
        // Data model
        resolvedData = resolvedState.resolvedData, allVisibleColumns = resolvedState.allVisibleColumns, headerGroups = resolvedState.headerGroups, hasHeaderGroups = resolvedState.hasHeaderGroups, 
        // Sorted Data
        sortedData = resolvedState.sortedData;
        // Pagination
        var startRow = pageSize * page;
        var endRow = startRow + pageSize;
        var pageRows = manual ? resolvedData : sortedData.slice(startRow, endRow);
        var minRows = this.getMinRows();
        var padRows = _.range(Math.max(minRows - pageRows.length, 0));
        var hasColumnFooter = allVisibleColumns.some(function (d) { return d.Footer; });
        var hasFilters = filterable || allVisibleColumns.some(function (d) { return d.filterable; });
        var recurseRowsViewIndex = function (rows, path, index) {
            if (path === void 0) { path = []; }
            if (index === void 0) { index = -1; }
            return ([
                rows.map(function (row, i) {
                    var _a;
                    index += 1;
                    var rowWithViewIndex = __assign(__assign({}, row), { viewIndex: index });
                    var newPath = path.concat([i]);
                    if (rowWithViewIndex[subRowsKey] && _.get(expanded, newPath)) {
                        _a = recurseRowsViewIndex(rowWithViewIndex[subRowsKey], newPath, index), rowWithViewIndex[subRowsKey] = _a[0], index = _a[1];
                    }
                    return rowWithViewIndex;
                }),
                index,
            ]);
        };
        pageRows = recurseRowsViewIndex(pageRows)[0];
        var canPrevious = page > 0;
        var canNext = page + 1 < pages;
        var rowMinWidth = _.sum(allVisibleColumns.map(function (d) {
            var resizedColumn = resized.find(function (x) { return x.id === d.id; })
                || { id: undefined, value: undefined };
            return _.getFirstDefined(resizedColumn.value, d.width, d.minWidth);
        }));
        var rowIndex = -1;
        var finalState = __assign(__assign({}, resolvedState), { startRow: startRow,
            endRow: endRow,
            pageRows: pageRows,
            minRows: minRows,
            padRows: padRows,
            hasColumnFooter: hasColumnFooter,
            canPrevious: canPrevious,
            canNext: canNext,
            rowMinWidth: rowMinWidth });
        var rootProps = getProps(finalState, undefined, undefined, this);
        var tableProps = getTableProps(finalState, undefined, undefined, this);
        var tBodyProps = getTbodyProps(finalState, undefined, undefined, this);
        var loadingProps = getLoadingProps(finalState, undefined, undefined, this);
        var noDataProps = getNoDataProps(finalState, undefined, undefined, this);
        // Visual Components
        var makeHeaderGroup = function (column, i) {
            var resizedValue = function (col) { return (resized.find(function (x) { return x.id === col.id; })
                || { id: undefined, value: undefined }).value; };
            var flex = _.sum(column.columns.map(function (col) { return (col.width || resizedValue(col) ? 0 : col.minWidth); }));
            var width = _.sum(column.columns.map(function (col) { return _.getFirstDefined(resizedValue(col), col.width, col.minWidth); }));
            var maxWidth = _.sum(column.columns.map(function (col) { return _.getFirstDefined(resizedValue(col), col.width, col.maxWidth); }));
            var theadGroupThProps = getTheadGroupProps(finalState, undefined, column, _this);
            var columnHeaderProps = column.getHeaderProps(finalState, undefined, column, _this);
            var rest = __assign(__assign(__assign({}, theadGroupThProps), columnHeaderProps), { CellTextComponent: CellTextComponent });
            var flexStyles = {
                flex: flex + " 0 auto",
                width: _.asPx(width),
                maxWidth: _.asPx(maxWidth),
            };
            return (React.createElement(ThComponent, __assign({ key: i + "-" + column.id, style: flexStyles }, rest), _.normalizeComponent(column.Header, {
                data: sortedData,
                column: column,
            })));
        };
        var selectRow = function (index) { return function (nextRow, childIndex) {
            var selectFirstAvailable = function (rows) {
                for (var i = 0; i < rows.length; i += 1) {
                    if (rows[i]) {
                        return rows[i].selectFirstChild(childIndex);
                    }
                }
                return false;
            };
            var found;
            if (typeof index === 'number') {
                var _a = _this.state, page_1 = _a.page, pages_1 = _a.pages;
                if (nextRow) {
                    if (pageRows.length > index + 1) {
                        found = _this.rowRef[index + 1].selectFirstChild(childIndex);
                    }
                    else if (page_1 < pages_1 - 1) {
                        _this.onPageChange(page_1 + 1);
                        found = true;
                    }
                    else {
                        found = selectFirstAvailable([_this.footerRef]);
                    }
                }
                else if (index > 0) {
                    found = _this.rowRef[index - 1].selectFirstChild(childIndex);
                }
                else if (page_1 > 0) {
                    _this.onPageChange(page_1 - 1);
                    found = true;
                }
                else {
                    found = selectFirstAvailable([_this.filterRef, _this.headerRef, _this.headerGroupsRef]);
                }
            }
            if (!found) {
                if (nextRow) {
                    focusNextElement(document);
                }
                else {
                    focusPrevElement(document);
                }
            }
        }; };
        var makeHeaderGroups = function () {
            var theadGroupProps = getTheadGroupProps(finalState, undefined, undefined, _this);
            var theadGroupTrProps = getTheadGroupTrProps(finalState, undefined, undefined, _this);
            return (React.createElement(TheadComponent, __assign({ style: { minWidth: rowMinWidth + "px" } }, theadGroupProps),
                React.createElement(TrComponent, __assign({ ref: function (el) { _this.headerGroupsRef = el; }, selectRow: selectRow('headerGroup') }, theadGroupTrProps), headerGroups.map(makeHeaderGroup))));
        };
        var makeHeader = function (column, i) {
            var resizedCol = resized.find(function (x) { return x.id === column.id; })
                || { id: undefined, value: undefined };
            var sort = sorted.find(function (d) { return d.id === column.id; });
            var show = typeof column.show === 'function' ? column.show() : column.show;
            var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            var theadThProps = getTheadThProps(finalState, undefined, column, _this);
            var columnHeaderProps = column.getHeaderProps(finalState, undefined, column, _this);
            var rest = __assign(__assign(__assign({}, theadThProps), columnHeaderProps), { CellTextComponent: CellTextComponent });
            var isResizable = _.getFirstDefined(column.resizable, resizable, false);
            var resizer = isResizable
                ? (React.createElement(ResizerComponent, __assign({ onMouseDown: function (e) { return _this.resizeColumnStart(e, column, false); }, onTouchStart: function (e) { return _this.resizeColumnStart(e, column, true); } }, getResizerProps(finalState, undefined, column, _this))))
                : null;
            var isSortable = _.getFirstDefined(column.sortable, sortable, false);
            return (React.createElement(ThComponent, __assign({ key: i + "-" + column.id, sort: sort && (sort.desc ? '-sort-desc' : '-sort-asc'), resizable: isResizable, sortable: isSortable, hidden: !show, expander: column.expander, pivot: pivotBy && pivotBy.slice(0, -1).includes(column.id), style: {
                    flex: width + " 0 auto",
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                }, toggleSort: function (e) {
                    if (isSortable)
                        _this.sortColumn(column, multiSort ? e.shiftKey : false);
                } }, rest),
                _.normalizeComponent(column.Header, {
                    data: sortedData,
                    column: column,
                }),
                resizer));
        };
        var makeHeaders = function () {
            var theadProps = getTheadProps(finalState, undefined, undefined, _this);
            var theadTrProps = getTheadTrProps(finalState, undefined, undefined, _this);
            return (React.createElement(TheadComponent, __assign({ header: true, style: {
                    minWidth: rowMinWidth + "px",
                } }, theadProps),
                React.createElement(TrComponent, __assign({ ref: function (el) { _this.headerRef = el; }, selectRow: selectRow('header') }, theadTrProps), allVisibleColumns.map(makeHeader))));
        };
        var makeFilter = function (column, i) {
            var resizedCol = resized.find(function (x) { return x.id === column.id; })
                || { id: undefined, value: undefined };
            var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            var theadFilterThProps = getTheadFilterThProps(finalState, undefined, column, _this);
            var filterInputProps = getFilterInputProps(finalState, undefined, column, _this);
            var columnHeaderProps = column.getFilterProps(finalState, undefined, column, _this);
            var rest = __assign(__assign(__assign({}, theadFilterThProps), columnHeaderProps), { CellTextComponent: CellTextComponent });
            var filter = filtered.find(function (filter) { return filter.id === column.id; });
            var ResolvedFilterComponent = column.Filter || FilterComponent;
            var isFilterable = _.getFirstDefined(column.filterable, filterable, false);
            return (React.createElement(ThComponent, __assign({ key: i + "-" + column.id, style: {
                    flex: width + " 0 auto",
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, rest), isFilterable
                ? _.normalizeComponent(ResolvedFilterComponent, __assign(__assign({}, filterInputProps), { column: column,
                    filter: filter, onChange: function (value) { return _this.filterColumn(column, value); } }), undefined)
                : null));
        };
        var makeFilters = function () {
            var theadFilterProps = getTheadFilterProps(finalState, undefined, undefined, _this);
            var theadFilterTrProps = getTheadFilterTrProps(finalState, undefined, undefined, _this);
            return (React.createElement(TheadComponent, __assign({ filters: true, style: {
                    minWidth: rowMinWidth + "px",
                } }, theadFilterProps),
                React.createElement(TrComponent, __assign({ ref: function (el) { _this.filterRef = el; }, selectRow: selectRow('filter') }, theadFilterTrProps), allVisibleColumns.map(makeFilter))));
        };
        var makePageRow = function (row, i, path) {
            if (path === void 0) { path = []; }
            var rowInfo = {
                original: row[originalKey],
                row: row,
                index: row[indexKey],
                viewIndex: rowIndex += 1,
                pageSize: pageSize,
                page: page,
                level: path.length,
                nestingPath: path.concat([i]),
                aggregated: row[aggregatedKey],
                groupedByPivot: row[groupedByPivotKey],
                subRows: row[subRowsKey],
            };
            var isExpanded = _.get(expanded, rowInfo.nestingPath);
            var trGroupProps = getTrGroupProps(finalState, rowInfo, undefined, _this);
            var expanderProps = getExpanderProps(finalState, rowInfo, undefined, _this);
            var trProps = getTrProps(row.viewIndex % 2, finalState, rowInfo, undefined, _this);
            return (React.createElement(TrGroupComponent, __assign({ key: rowInfo.nestingPath.join('_') }, trGroupProps),
                React.createElement(TrComponent, __assign({ selectRow: selectRow(i), ref: function (el) { _this.rowRef[i] = el; }, rowIndex: row.viewIndex }, trProps), allVisibleColumns.map(function (column, i2) {
                    var defaultTdProps = {};
                    var resizedCol = resized.find(function (x) { return x.id === column.id; })
                        || { id: undefined, value: undefined };
                    var show = typeof column.show === 'function' ? column.show() : column.show;
                    var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
                    var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
                    var tdProps = getTdProps(finalState, rowInfo, column, _this);
                    var columnProps = column.getProps(finalState, rowInfo, column);
                    var cellInfo = __assign(__assign(__assign(__assign({}, rowInfo), { isExpanded: isExpanded, column: __assign({}, column), value: rowInfo.row[column.id], pivoted: column.pivoted, expander: column.expander, expandable: undefined, resized: resized,
                        show: show,
                        width: width,
                        maxWidth: maxWidth }), tdProps), columnProps);
                    var value = cellInfo.value;
                    var useOnExpanderClick;
                    var isBranch;
                    var isPreview;
                    var onExpanderClick = function (e) {
                        var newExpanded = _.clone(expanded);
                        if (isExpanded) {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, false);
                        }
                        else {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, {});
                        }
                        return _this.setStateWithData({
                            expanded: newExpanded,
                        }, _this.state, _this.props, function () { return (onExpandedChange
                            && onExpandedChange(newExpanded, cellInfo.nestingPath, e)); });
                    };
                    // Default to a standard cell
                    if (column.Cell) {
                        value = _.normalizeComponent(column.Cell, cellInfo, value);
                    }
                    var cellProps = __assign(__assign({}, tdProps), columnProps);
                    var resolvedCell = React.createElement(CellTextComponent, __assign({ value: value }, cellProps));
                    // Resolve Renderers
                    var ResolvedAggregatedComponent = column.Aggregated
                        || (!column.aggregate ? AggregatedComponent : column.Cell);
                    var ResolvedExpanderComponent = column.Expander || ExpanderComponent;
                    var ResolvedPivotValueComponent = column.PivotValue || PivotValueComponent;
                    var DefaultResolvedPivotComponent = PivotComponent
                        || (function (props) { return (React.createElement(React.Fragment, null,
                            React.createElement(ResolvedExpanderComponent, __assign({}, __assign(__assign({}, props), { expanderProps: expanderProps }))),
                            React.createElement(ResolvedPivotValueComponent, __assign({}, props)))); });
                    var ResolvedPivotComponent = column.Pivot || DefaultResolvedPivotComponent;
                    // Is this cell expandable?
                    if (cellInfo.pivoted || cellInfo.expander) {
                        // Make it expandable by defualt
                        cellInfo.expandable = true;
                        useOnExpanderClick = true;
                        // If pivoted, has no subRows, and does not have a subComponent,
                        // do not make expandable
                        if (cellInfo.pivoted && !cellInfo.subRows && !SubComponent) {
                            cellInfo.expandable = false;
                        }
                    }
                    if (cellInfo.pivoted) {
                        // Is this column a branch?
                        isBranch = rowInfo.row[pivotIDKey] === column.id && cellInfo.subRows;
                        // Should this column be blank?
                        isPreview = pivotBy.indexOf(column.id)
                            > pivotBy.indexOf(rowInfo.row[pivotIDKey]) && cellInfo.subRows;
                        // Pivot Cell Render Override
                        if (isBranch) {
                            // isPivot
                            resolvedCell = _.normalizeComponent(ResolvedPivotComponent, __assign(__assign({}, cellInfo), { value: row[pivotValKey] }), row[pivotValKey]);
                        }
                        else if (isPreview) {
                            // Show the pivot preview
                            resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                        }
                        else {
                            resolvedCell = null;
                        }
                    }
                    else if (cellInfo.aggregated) {
                        resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                    }
                    if (cellInfo.expander) {
                        defaultTdProps = expanderTdDefaultProps;
                        resolvedCell = _.normalizeComponent(ResolvedExpanderComponent, __assign(__assign({}, cellInfo), { expanderProps: expanderProps }), row[pivotValKey]);
                        if (pivotBy) {
                            if (cellInfo.groupedByPivot) {
                                resolvedCell = null;
                            }
                            if (!cellInfo.subRows && !SubComponent) {
                                resolvedCell = null;
                            }
                        }
                    }
                    var resolvedOnExpanderClick = useOnExpanderClick
                        ? onExpanderClick
                        : function () { };
                    // If there are multiple onClick events, make sure they don't
                    // override eachother. This should maybe be expanded to handle all
                    // function attributes
                    var interactionProps = {
                        onClick: resolvedOnExpanderClick,
                    };
                    if (tdProps.onClick) {
                        interactionProps.onClick = function (e) {
                            tdProps.onClick(e, function () { return resolvedOnExpanderClick(e); });
                        };
                    }
                    if (columnProps.onClick) {
                        interactionProps.onClick = function (e) {
                            columnProps.onClick(e, function () { return resolvedOnExpanderClick(e); });
                        };
                    }
                    // Return the cell
                    return (React.createElement(TdComponent
                    // eslint-disable-next-line react/no-array-index-key
                    , __assign({ 
                        // eslint-disable-next-line react/no-array-index-key
                        key: i2 + "-" + column.id, hidden: !show, style: {
                            flex: width + " 0 auto",
                            width: _.asPx(width),
                            maxWidth: _.asPx(maxWidth),
                        } }, tdProps, columnProps, interactionProps, defaultTdProps), resolvedCell));
                })),
                rowInfo.subRows
                    && isExpanded
                    && rowInfo.subRows.map(function (d, i) { return makePageRow(d, i, rowInfo.nestingPath); }),
                SubComponent
                    && !rowInfo.subRows
                    && isExpanded
                    && SubComponent(rowInfo)));
        };
        var makePadColumn = function (column, i) {
            var resizedCol = resized.find(function (x) { return x.id === column.id; })
                || { id: undefined, value: undefined };
            var show = typeof column.show === 'function' ? column.show() : column.show;
            var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            var flex = width;
            var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            var tdProps = getTdProps(finalState, undefined, column, _this);
            return (React.createElement(TdComponent, __assign({ key: i + "-" + column.id, hidden: !show, style: {
                    flex: flex + " 0 auto",
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, tdProps), _.normalizeComponent(PadRowComponent)));
        };
        var makePadRow = function (row, i) {
            var trGroupProps = getTrGroupProps(finalState, undefined, undefined, _this);
            var trProps = getTrProps(row.viewIndex % 2, finalState, undefined, undefined, _this);
            return (React.createElement(TrGroupComponent, __assign({ key: i }, trGroupProps),
                React.createElement(TrComponent, __assign({ padrow: true, even: (pageRows.length + i) % 2 }, trProps), allVisibleColumns.map(makePadColumn))));
        };
        var makeColumnFooter = function (column, i) {
            var resizedCol = resized.find(function (x) { return x.id === column.id; })
                || { id: undefined, value: undefined };
            var show = typeof column.show === 'function' ? column.show() : column.show;
            var width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            var maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            var tFootTdProps = getTfootTdProps(finalState, undefined, undefined, _this);
            var columnProps = column.getProps(finalState, undefined, column, _this);
            var columnFooterProps = column.getFooterProps(finalState, undefined, column, _this);
            return (React.createElement(TdComponent, __assign({ key: i + "-" + column.id, hidden: !show, style: {
                    flex: width + " 0 auto",
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, columnProps, tFootTdProps, columnFooterProps), _.normalizeComponent(column.Footer, {
                data: sortedData,
                column: column,
            })));
        };
        var makeColumnFooters = function () {
            var tFootProps = getTfootProps(finalState, undefined, undefined, _this);
            var tFootTrProps = getTfootTrProps(finalState, undefined, undefined, _this);
            return (React.createElement(TfootComponent, __assign({ style: {
                    minWidth: rowMinWidth + "px",
                } }, tFootProps),
                React.createElement(TrComponent, __assign({ ref: function (el) { _this.footerRef = el; }, selectRow: selectRow('footer') }, tFootTrProps), allVisibleColumns.map(makeColumnFooter))));
        };
        var makePagination = function () {
            var paginationProps = getPaginationProps(finalState, undefined, undefined, _this);
            return (React.createElement(PaginationComponent, __assign({}, resolvedState, { pages: pages, canPrevious: canPrevious, canNext: canNext, onPageChange: _this.onPageChange, onPageSizeChange: _this.onPageSizeChange }, paginationProps)));
        };
        var makeTable = function () {
            var pagination = makePagination();
            return (React.createElement("div", __assign({}, rootProps),
                showPagination && showPaginationTop ? (React.createElement("div", null, pagination))
                    : null,
                React.createElement(TableComponent, __assign({}, tableProps),
                    hasHeaderGroups ? makeHeaderGroups() : null,
                    makeHeaders(),
                    hasFilters ? makeFilters() : null,
                    React.createElement(TbodyComponent, __assign({ style: {
                            minWidth: rowMinWidth + "px",
                        } }, tBodyProps),
                        React.createElement(LoadingComponent, __assign({ loading: loading, loadingText: loadingText }, loadingProps)),
                        pageRows.map(function (d, i) { return makePageRow(d, i); }),
                        padRows.map(makePadRow)),
                    hasColumnFooter ? makeColumnFooters() : null),
                showPagination && showPaginationBottom ? (React.createElement("div", null, pagination))
                    : null,
                !pageRows.length && !loading
                    && (React.createElement(NoDataComponent, __assign({}, noDataProps), _.normalizeComponent(noDataText)))));
        };
        // childProps are optionally passed to a function-as-a-child
        return makeTable();
    };
    ReactTable.defaultProps = defaultProps;
    ReactTable.getDataModel = function (newState, props) {
        var columns = newState.columns, _a = newState.pivotBy, pivotBy = _a === void 0 ? [] : _a, data = newState.data, pivotIDKey = newState.pivotIDKey, pivotValKey = newState.pivotValKey, subRowsKey = newState.subRowsKey, aggregatedKey = newState.aggregatedKey, nestingLevelKey = newState.nestingLevelKey, originalKey = newState.originalKey, indexKey = newState.indexKey, groupedByPivotKey = newState.groupedByPivotKey, SubComponent = newState.SubComponent;
        // Determine Header Groups
        var hasHeaderGroups = false;
        columns.forEach(function (column) {
            if (column.columns) {
                hasHeaderGroups = true;
            }
        });
        var columnsWithExpander = __spreadArrays(columns);
        var expanderColumn = columns.find(function (col) { return col.expander
            || (col.columns && col.columns.some(function (col2) { return col2.expander; })); });
        // The actual expander might be in the columns field of a group column
        if (expanderColumn && !expanderColumn.expander) {
            expanderColumn = expanderColumn.columns.find(function (col) { return col.expander; });
        }
        // If we have SubComponent's we need to make sure we have an expander column
        if (SubComponent && !expanderColumn) {
            expanderColumn = { expander: true };
            columnsWithExpander = __spreadArrays([expanderColumn], columnsWithExpander);
        }
        var makeDecoratedColumn = function (column, parentColumn) {
            var dcol;
            if (column.expander) {
                dcol = __assign(__assign(__assign({}, props.column), props.expanderDefaults), column);
            }
            else {
                dcol = __assign(__assign({}, props.column), column);
            }
            // Ensure minWidth is not greater than maxWidth if set
            if (dcol.maxWidth < dcol.minWidth) {
                dcol.minWidth = dcol.maxWidth;
            }
            if (parentColumn) {
                dcol.parentColumn = parentColumn;
            }
            // First check for string accessor
            if (typeof dcol.accessor === 'string') {
                dcol.id = dcol.id || dcol.accessor;
                var accessorString_1 = dcol.accessor;
                dcol.accessor = function (row) { return _.get(row, accessorString_1); };
                return dcol;
            }
            // Fall back to functional accessor (but require an ID)
            if (dcol.accessor && !dcol.id) {
                console.warn(dcol);
                throw new Error('A column id is required if using a non-string accessor for column above.');
            }
            // Fall back to an undefined accessor
            if (!dcol.accessor) {
                dcol.accessor = function () { return undefined; };
            }
            return dcol;
        };
        var allDecoratedColumns = [];
        // Decorate the columns
        var decorateAndAddToAll = function (column, parentColumn) {
            var decoratedColumn = makeDecoratedColumn(column, parentColumn);
            allDecoratedColumns.push(decoratedColumn);
            return decoratedColumn;
        };
        var decoratedColumns = columnsWithExpander.map(function (column) {
            if (column.columns) {
                return __assign(__assign({}, column), { columns: column.columns.map(function (d) { return decorateAndAddToAll(d, column); }) });
            }
            return decorateAndAddToAll(column);
        });
        // Build the visible columns, headers and flat column list
        var visibleColumns = decoratedColumns.slice();
        var allVisibleColumns = [];
        visibleColumns = visibleColumns.map(function (column) {
            if (column.columns) {
                var visibleSubColumns = column.columns.filter(function (d) { return (pivotBy.indexOf(d.id) > -1
                    ? false
                    : _.getFirstDefined(d.show, true)); });
                return __assign(__assign({}, column), { columns: visibleSubColumns });
            }
            return column;
        });
        visibleColumns = visibleColumns.filter(function (column) { return (column.columns
            ? column.columns.length
            : pivotBy.indexOf(column.id) > -1
                ? false
                : _.getFirstDefined(column.show, true)); });
        // Find any custom pivot location
        var pivotIndex = visibleColumns.findIndex(function (col) { return col.pivot; });
        // Handle Pivot Columns
        if (pivotBy.length) {
            // Retrieve the pivot columns in the correct pivot order
            var pivotColumns_1 = [];
            pivotBy.forEach(function (pivotID) {
                var found = allDecoratedColumns.find(function (d) { return d.id === pivotID; });
                if (found) {
                    pivotColumns_1.push(found);
                }
            });
            var PivotParentColumn = pivotColumns_1.reduce(function (prev, current) { return prev && prev === current.parentColumn && current.parentColumn; }, pivotColumns_1[0].parentColumn);
            var PivotGroupHeader = hasHeaderGroups && (PivotParentColumn ? PivotParentColumn.Header
                : (pivotColumns_1[0].PivotHeader || pivotColumns_1[0].Header));
            var pivotColumnGroup = {
                Header: PivotGroupHeader,
                columns: pivotColumns_1.map(function (col) { return (__assign(__assign(__assign({}, props.pivotDefaults), col), { pivoted: true })); }),
            };
            // Place the pivotColumns back into the visibleColumns
            if (pivotIndex >= 0) {
                pivotColumnGroup = __assign(__assign({}, visibleColumns[pivotIndex]), pivotColumnGroup);
                visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);
            }
            else {
                visibleColumns.unshift(pivotColumnGroup);
            }
        }
        // Build Header Groups
        var headerGroups = [];
        var currentSpan = [];
        // A convenience function to add a header and reset the currentSpan
        var addHeader = function (columns, column) {
            headerGroups.push(__assign(__assign(__assign({}, props.column), column), { columns: columns }));
            currentSpan = [];
        };
        // Build flast list of allVisibleColumns and HeaderGroups
        visibleColumns.forEach(function (column) {
            if (column.columns) {
                allVisibleColumns = allVisibleColumns.concat(column.columns);
                if (currentSpan.length > 0) {
                    addHeader(currentSpan);
                }
                addHeader(column.columns, column);
                return;
            }
            allVisibleColumns.push(column);
            currentSpan.push(column);
        });
        if (hasHeaderGroups && currentSpan.length > 0) {
            addHeader(currentSpan);
        }
        // Access the data
        var accessRow = function (d, i, level) {
            var _a;
            if (level === void 0) { level = 0; }
            var row = (_a = {},
                _a[originalKey] = d,
                _a[indexKey] = i,
                _a[subRowsKey] = d[subRowsKey],
                _a[nestingLevelKey] = level,
                _a);
            allDecoratedColumns.forEach(function (column) {
                if (column.expander)
                    return;
                row[column.id] = column.accessor(d);
            });
            if (row[subRowsKey]) {
                row[subRowsKey] = row[subRowsKey].map(function (d, i) { return accessRow(d, i, level + 1); });
            }
            return row;
        };
        var resolvedData = data.map(function (d, i) { return accessRow(d, i); });
        var aggregatingColumns = allVisibleColumns.filter(function (d) { return !d.expander && d.aggregate; });
        // If pivoting, recursively group the data
        var aggregate = function (rows) {
            var aggregationValues = {};
            aggregatingColumns.forEach(function (column) {
                var values = rows.map(function (d) { return d[column.id]; });
                aggregationValues[column.id] = column.aggregate(values, rows);
            });
            return aggregationValues;
        };
        if (pivotBy.length) {
            var groupRecursively_1 = function (rows, keys, i) {
                if (i === void 0) { i = 0; }
                // This is the last level, just return the rows
                if (i === keys.length) {
                    return rows;
                }
                // Group the rows together for this level
                var groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(function (_a) {
                    var _b;
                    var key = _a[0], value = _a[1];
                    return (_b = {},
                        _b[pivotIDKey] = keys[i],
                        _b[pivotValKey] = key,
                        _b[keys[i]] = key,
                        _b[subRowsKey] = value,
                        _b[nestingLevelKey] = i,
                        _b[groupedByPivotKey] = true,
                        _b);
                });
                // Recurse into the subRows
                groupedRows = groupedRows.map(function (rowGroup) {
                    var _a;
                    var subRows = groupRecursively_1(rowGroup[subRowsKey], keys, i + 1);
                    return __assign(__assign(__assign({}, rowGroup), (_a = {}, _a[subRowsKey] = subRows, _a[aggregatedKey] = true, _a)), aggregate(subRows));
                });
                return groupedRows;
            };
            resolvedData = groupRecursively_1(resolvedData, pivotBy);
        }
        return __assign(__assign({}, newState), { resolvedData: resolvedData,
            allVisibleColumns: allVisibleColumns,
            headerGroups: headerGroups,
            allDecoratedColumns: allDecoratedColumns,
            hasHeaderGroups: hasHeaderGroups });
    };
    ReactTable.getSortedData = function (resolvedState, props) {
        var manual = resolvedState.manual, sorted = resolvedState.sorted, filtered = resolvedState.filtered, defaultFilterMethod = resolvedState.defaultFilterMethod, resolvedData = resolvedState.resolvedData, allVisibleColumns = resolvedState.allVisibleColumns, allDecoratedColumns = resolvedState.allDecoratedColumns;
        var sortMethodsByColumnID = {};
        allDecoratedColumns.filter(function (col) { return col.sortMethod; }).forEach(function (col) {
            sortMethodsByColumnID[col.id] = col.sortMethod;
        });
        // Resolve the data from either manual data or sorted data
        return {
            sortedData: manual
                ? resolvedData
                : ReactTable.sortData(ReactTable.filterData(resolvedData, filtered, defaultFilterMethod, allVisibleColumns, props), sorted, sortMethodsByColumnID, props),
        };
    };
    ReactTable.filterData = function (data, filtered, defaultFilterMethod, allVisibleColumns, props) {
        var filteredData = data;
        if (filtered.length) {
            filteredData = filtered.reduce(function (filteredSoFar, nextFilter) {
                var column = allVisibleColumns.find(function (x) { return x.id === nextFilter.id; });
                // Don't filter hidden columns or columns that have had their filters disabled
                if (!column || column.filterable === false) {
                    return filteredSoFar;
                }
                var filterMethod = column.filterMethod || defaultFilterMethod;
                // If 'filterAll' is set to true, pass the entire dataset to the filter method
                if (column.filterAll) {
                    return filterMethod(nextFilter, filteredSoFar, column);
                }
                return filteredSoFar.filter(function (row) { return (filterMethod(nextFilter, row, column)); });
            }, filteredData);
            // Apply the filter to the subrows if we are pivoting, and then
            // filter any rows without subcolumns because it would be strange to show
            filteredData = filteredData
                .map(function (row) {
                var _a;
                if (!row[props.subRowsKey]) {
                    return row;
                }
                return __assign(__assign({}, row), (_a = {}, _a[props.subRowsKey] = ReactTable.filterData(row[props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns, props), _a));
            })
                .filter(function (row) {
                if (!row[props.subRowsKey]) {
                    return true;
                }
                return row[props.subRowsKey].length > 0;
            });
        }
        return filteredData;
    };
    ReactTable.sortData = function (data, sorted, sortMethodsByColumnID, props) {
        if (sortMethodsByColumnID === void 0) { sortMethodsByColumnID = {}; }
        if (!sorted.length) {
            return data;
        }
        var sortedData = _.orderBy(data, sorted.map(function (sort) {
            // Support custom sorting methods for each column
            if (sortMethodsByColumnID[sort.id]) {
                return function (a, b) { return (sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc)); };
            }
            return function (a, b) { return (props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc)); };
        }), sorted.map(function (d) { return !d.desc; }), props.indexKey);
        sortedData.forEach(function (row) {
            if (!row[props.subRowsKey]) {
                return;
            }
            row[props.subRowsKey] = ReactTable.sortData(row[props.subRowsKey], sorted, sortMethodsByColumnID, props);
        });
        return sortedData;
    };
    return ReactTable;
}(Component));
export default ReactTable;
